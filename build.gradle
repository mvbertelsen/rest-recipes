plugins {
    id "com.eriwen.gradle.js" version "1.12.1"
}

apply plugin: 'java'
apply plugin: 'groovy'
apply plugin: 'war'
apply plugin: 'idea'
apply plugin: 'jetty'


repositories {
    mavenCentral()
}

configurations {
    functionalCompile.extendsFrom testCompile
    functionalRuntime.extendsFrom testRuntime
}

dependencies {
    compile 'org.slf4j:slf4j-api:1.7.7'
    compile 'org.apache.logging.log4j:log4j-api:2.0.2'
    compile 'org.apache.logging.log4j:log4j-core:2.0.2'
    compile 'org.apache.logging.log4j:log4j-slf4j-impl:2.0.2'
    compile 'org.glassfish.jersey.containers:jersey-container-servlet:2.12'
	compile 'org.glassfish.jersey.media:jersey-media-json-jackson:2.12'
	compile 'org.codehaus.groovy:groovy-all:2.3.6'
    testCompile 'junit:junit:4.11'
    testCompile 'org.hamcrest:hamcrest-all:1.3'
    testCompile 'org.unitils:unitils-core:3.3'
    testCompile 'org.seleniumhq.selenium:selenium-java:2.43.1'
    testCompile 'org.seleniumhq.selenium:selenium-chrome-driver:2.43.1'
    testCompile 'org.codehaus.groovy.modules.http-builder:http-builder:0.7.1'
}

test {
    exclude "api/**"
    exclude "app/**"
}

sourceSets {
    functional {
        // this is so the functional tests can use the same resource classes as the app
        compileClasspath += main.output
        runtimeClasspath += main.output
        groovy {
            srcDir 'src/functional/groovy'
        }
    }
}

javascript.source {
    dev {
        js {
            srcDir 'src'
            include 'main/webapp/js/app/**/*.js', 'test/javascript/**/*.js'
        }
    }
}

jshint {
    tasks.jshint.source = javascript.source.dev.js.files
    tasks.jshint.ignoreExitCode=false
    tasks.jshint.outputToStdOut=true
}

task karma(type:Exec) {
    commandLine 'node', 'node_modules/karma/bin/karma', 'start', '--single-run', 'true'
}

task functional(type: Test) {
    testClassesDir = sourceSets.functional.output.classesDir
    classpath = sourceSets.functional.runtimeClasspath
}

jettyRun.with {
    daemon = true
    webDefaultXml = file("${project.webAppDir}/WEB-INF/jetty-webdefault.xml")
}

[jettyRun, jettyRunWar,jettyStop]*.with {
    stopPort = 8090
    stopKey = 'arglebargle'
}

functional.dependsOn jettyRun
functional.finalizedBy jettyStop

// need a way to start the server and have it wait since the default is daemon for functional
task startServer(dependsOn: classes) << {
    jettyRun.daemon = false
    jettyRun.execute()
}

